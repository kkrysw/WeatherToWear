# -*- coding: utf-8 -*-
"""Final Backend.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/11XUcx9WUJI6Xkx_xOzh-3AScdC7jyVfH

# **Rent the Runway Web Scraping**
"""

!apt-get install python3-dev libmysqlclient-dev > /dev/null
!pip install mysqlclient > /dev/null
!pip install -U sql_magic > /dev/null
!pip install psycopg2-binary > /dev/null

!pip install -U 'sqlalchemy<2.0'

import pandas as pd
from sqlalchemy import create_engine
import requests

"""### **Connection to our SQL Database**"""

#set up connection to SQL database (reference the mySQL notebook prof. sedoc built for us!)

def connect_mysql():
    conn_string = 'mysql://{user}:{password}@{host}:{port}/{db}?charset=utf8'.format(
        user='WeatherToWear',
        password='6u36kMD9akk=',
        host='jsedocc7.scrc.nyu.edu',
        port=3306,
        db='WeatherToWear'
    )
    engine = create_engine(conn_string)
    return engine

#create inventory table, execute command, and then disconnect

def create_inventory_table(engine):
    with engine.connect() as conn:
        conn.execute("""
            CREATE TABLE IF NOT EXISTS inventory(
                `index` INT AUTO_INCREMENT PRIMARY KEY,
                `id` TEXT NOT NULL,
                `category` TEXT,
                `image` TEXT,
                `displayName` TEXT,
                `urlHistory` TEXT
            )
        """)

"""### **Scraping RTR**"""

#retrieve data from RTR

def get_category(engine, category):
    has_next_page = True
    current_page = 1

    if category == 'dresses':
        url = 'https://www.renttherunway.com/c/'
    else:
        url = 'https://www.renttherunway.com/products/clothing/'

    while has_next_page:
        response = requests.get(url+category,
            params={'filters[zip_code]': '10010', 'page': current_page},
            headers={'accept': 'application/json, text/javascript, */*; q=0.01', 'x-requested-with': 'XMLHttpRequest'})
        json_response = response.json()
        products = json_response['products']
        total_pages = json_response['totalPages']
        next_page = json_response['next_page']

        with engine.connect() as conn:
            for product in products:
                try:
                    product['images']['front']
                    conn.execute("""
                        INSERT INTO inventory (id, category, image, displayName, urlHistory)
                        VALUES (%s, %s, %s, %s, %s)
                    """, (product['id'], category, product['images']['front']['270x'], product['displayName'], product['urlHistory'][-1]))
                except Exception as e:
                  print(f"Error: {e}")
                  continue

        print(category)
        print(f'Current page: {current_page}')
        print(f'Number of products collected: {len(products)}')
        print(f'Pages left: {total_pages-current_page}')

        if next_page:
            has_next_page = True
            current_page += 1
        else:
            has_next_page = False

#execute code
engine=connect_mysql()
create_inventory_table(engine)
categories=['top','bottom','dresses','jumpsuit_romper','knit','jacket_coat']
for category in categories:
  get_category(engine, category)

#read the database and create a dataframe with RTR data
conn=connect_mysql()
inventory_df=pd.read_sql('SELECT * FROM inventory', conn)
prefix = 'https://pc-ap.rtrcdn.com/'
inventory_df['image']=inventory_df['image'].apply(lambda x: prefix + x)
print(inventory_df)

inventory_df.head(3)

inventory_df.tail(3)

inventory_df.sample(3)

"""### **Categorizing Images**"""

## STYLE
!pip install mysqlclient
!pip install pymysql

import requests
from PIL import Image
from io import BytesIO
import pandas as pd
from sqlalchemy import create_engine
from sqlalchemy import text
from transformers import CLIPProcessor, CLIPModel
import torch
import json  # to handle conversion of dictionary to string

# Initialize the CLIP model
processor = CLIPProcessor.from_pretrained("openai/clip-vit-base-patch32")
model = CLIPModel.from_pretrained("openai/clip-vit-base-patch32")
device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
model.to(device)

# Function to connect to the SQL database
def connect_mysql():
    conn_string = 'mysql+mysqldb://{user}:{password}@{host}:{port}/{db}?charset=utf8'.format(
        user='WeatherToWear',
        password='6u36kMD9akk=',
        host='jsedocc7.scrc.nyu.edu',
        port=3306,
        db='WeatherToWear'
    )
    engine = create_engine(conn_string)
    return engine

conn = connect_mysql()

# retrieving inventory from the database
inventory_df = pd.read_sql('SELECT * FROM inventory', conn)

# Define style attributes for classification
style_attributes = [
    "classy", "casual", "modern", "vintage", "sophisticated", "chic", "trendy",
    "timeless", "fashionable", "sleek", "stylish", "glamorous", "edgy", "bohemian",
    "refined", "polished", "avant-garde", "eclectic", "effortless", "urban", "couture"]

# Function to classify image style with correct URL and image processing
def classify_image_style(image_url):
    base_url = "https://pc-ap.rtrcdn.com/"
    full_url = base_url + image_url
    try:
        response = requests.get(full_url)
        image = Image.open(BytesIO(response.content)).convert("RGB")
        inputs = processor(text=style_attributes, images=image, return_tensors="pt", padding=True).to(device)
        outputs = model(**inputs)
        probs = outputs.logits_per_image.softmax(dim=1).squeeze().tolist()
        style_scores = dict(zip(style_attributes, probs))
        return style_scores
    except Exception as e:
        print(f"Error processing image at {full_url}: {e}")
        return None

# Function to update the database with the style attribute
def update_style(engine, index, style_scores):
    style_scores_json = json.dumps(style_scores)
    with engine.connect() as conn:
        conn.execute(text("""
            UPDATE inventory
            SET style_scores = :style_scores
            WHERE `index` = :index
        """), {'style_scores': style_scores_json, 'index': index})

for index, row in inventory_df.iterrows():
    style_scores = classify_image_style(row['image'])
    if style_scores:
        update_style(conn, row['index'], style_scores)
        print(f"Updated {row['displayName']} with style scores.")
    else:
        print(f"Skipped updating {row['displayName']} due to errors.")

# Close the database connection
conn.dispose()

## WEATHER
!pip install mysqlclient
!pip install pymysql


import requests
from PIL import Image
from io import BytesIO
import pandas as pd
from sqlalchemy import create_engine
from sqlalchemy import text
from transformers import CLIPProcessor, CLIPModel, CLIPTextModel
import torch

# Initialize the CLIP model
processor = CLIPProcessor.from_pretrained("openai/clip-vit-base-patch32")
model = CLIPModel.from_pretrained("openai/clip-vit-base-patch32")

# Function to connect to the SQL database
def connect_mysql():
    conn_string = 'mysql+mysqldb://{user}:{password}@{host}:{port}/{db}?charset=utf8'.format(
        user='WeatherToWear',
        password='6u36kMD9akk=',
        host='jsedocc7.scrc.nyu.edu',
        port=3306,
        db='WeatherToWear'
    )
    engine = create_engine(conn_string)
    return engine

conn = connect_mysql()

#  retrieving inventory from the database
inventory_df = pd.read_sql('SELECT * FROM inventory', conn)

# define weather attributes for classification
weather_attributes = ["waterproof", "breathable", "sleeveless", "insulated", "windproof", "lightweight", "layered", "all-season"]

# Function to classify image weather with correct URL and image processing
def classify_image_weather(image_url, descriptionList):
    base_url = "https://pc-ap.rtrcdn.com/"
    full_url = base_url + image_url
    try:
        response = requests.get(full_url)
        image = Image.open(BytesIO(response.content)).convert("RGB")
        inputs = processor(text= descriptionList, images=image, return_tensors="pt", padding = True)
        outputs = model(**inputs)
        logits_per_image = outputs.logits_per_image
        probs = logits_per_image.softmax(dim=1)
        print(probs)
        results = dict(zip(descriptionList, probs.tolist()[0]))
        print(results)
        return max(results, key=results.get)
    except Exception as e:
        print(f"Error processing image at {full_url}: {e}")
        return None

# Function to update the database with the weather attribute
def update_weather(engine, index, weather):
    print(weather, index)
    print(f"""
            UPDATE inventory
            SET weather = {weather}
            WHERE `index` = {index}
""")
    with engine.connect() as conn:
        conn.execute(text(f""" UPDATE inventory SET weather = "{weather}" WHERE `index` = {index}"""))



# Classify and update images
for index, row in inventory_df.iterrows():
    if pd.isnull(row['weather']):  # Check if weather is null
        weather = classify_image_weather(row['image'], ["waterproof", "breathable", "insulated", "windproof", "lightweight", "layered", "all-season"])
        if weather:
            update_weather(conn, row['index'], weather)
            print(f"Updated {row['displayName']} with weather {weather}")
        else:
            print(f"Skipped updating {row['displayName']} due to errors.")
    else:
        print(f"Skipping {row['displayName']} because weather value already exists.")


# Close the database connection
conn.dispose()

## COLORS
!pip install mysqlclient
!pip install pymysql


import requests
from PIL import Image
from io import BytesIO
import pandas as pd
from sqlalchemy import create_engine
from sqlalchemy import text
from transformers import CLIPProcessor, CLIPModel, CLIPTextModel
import torch

# Initialize the CLIP model
processor = CLIPProcessor.from_pretrained("openai/clip-vit-base-patch32")
model = CLIPModel.from_pretrained("openai/clip-vit-base-patch32")



# Function to connect to the SQL database
def connect_mysql():
    conn_string = 'mysql+mysqldb://{user}:{password}@{host}:{port}/{db}?charset=utf8'.format(
        user='WeatherToWear',
        password='6u36kMD9akk=',
        host='jsedocc7.scrc.nyu.edu',
        port=3306,
        db='WeatherToWear'
    )
    engine = create_engine(conn_string)
    return engine

conn = connect_mysql()

#  retrieving inventory from the database
inventory_df = pd.read_sql('SELECT * FROM inventory', conn)

# define color attributes for classification
color_attributes = ["pastel", "dark", "light", "black", "white", "multicolored", "patterned", "earthy", "neutral"]

# Function to classify image color with correct URL and image processing
def classify_image_color(image_url, descriptionList):
    base_url = "https://pc-ap.rtrcdn.com/"
    full_url = base_url + image_url
    try:
        response = requests.get(full_url)
        image = Image.open(BytesIO(response.content)).convert("RGB")
        inputs = processor(text= descriptionList, images=image, return_tensors="pt", padding = True)
        outputs = model(**inputs)
        logits_per_image = outputs.logits_per_image
        probs = logits_per_image.softmax(dim=1)
        print(probs)
        results = dict(zip(descriptionList, probs.tolist()[0]))
        print(results)
        return max(results, key=results.get)
    except Exception as e:
        print(f"Error processing image at {full_url}: {e}")
        return None

# Function to update the database with the color attribute
def update_color(engine, index, color):
    print(color, index)
    print(f"""
            UPDATE inventory
            SET color = {color}
            WHERE `index` = {index}
""")
    with engine.connect() as conn:
        conn.execute(text(f""" UPDATE inventory SET color = "{color}" WHERE `index` = {index}"""))



# Classify and update images
for index, row in inventory_df.iterrows():
    if pd.isnull(row['color']):
        color = classify_image_color(row['image'], ["pastel", "dark", "light", "black", "white", "multicolored", "patterned", "earthy", "neutral"])
        if color:
            update_color(conn, row['index'], color)
            print(f"Updated {row['displayName']} with color {color}")
        else:
            print(f"Skipped updating {row['displayName']} due to errors.")
    else:
        print(f"Skipping {row['displayName']} because color value already exists.")


# Close the database connection
conn.dispose()



"""### **Data Analysis**"""

import matplotlib.pyplot as plt
import seaborn as sns
import pandas as pd

# 1. Basic Information
inventory_df.info()

inventory_df.head()

inventory_df.tail() # not fully updated

inventory_df.sample(5)

category_counts = inventory_df['category'].value_counts()

# Relabel the categories
category_counts_relabel = category_counts.rename({
    'dresses': 'Dress',
    'top': 'Top',
    'bottom': 'Bottom',
    'knit': 'Knit',
    'jacket_coat': 'Jacket / Coat',
    'jumpsuit_romper': 'Jumpsuit / Romper'
})

# Category counts
## This bar plot illustrates the distribution of clothing items across different categories, such as dresses, tops, bottoms, etc.

print("Category Value Counts:")
print(category_counts_relabel)

plt.figure(figsize=(10, 6))
ax = category_counts_relabel.plot(kind='bar')
plt.title('Distribution of Categories')
plt.xlabel('Category')
plt.ylabel('Count')
plt.xticks(rotation=30)

for i in ax.patches:
    plt.text(i.get_x() + i.get_width()/2, i.get_height(), str(round(i.get_height(), 2)), ha='center', va='bottom')

plt.show()

# Style
## This bar plot visualizes the frequency of each style, such as chic, elegant, modern, etc., indicating the popularity of different fashion styles.

plt.figure(figsize=(10, 6))
sns.countplot(data=inventory_df, x='style', order=inventory_df['style'].value_counts().index)
plt.title('Distribution of Clothing Styles')
plt.xlabel('Style')
plt.ylabel('Count')
plt.xticks(rotation=30)

ax = plt.gca()
for p in ax.patches:
    ax.annotate(f'{int(p.get_height())}', (p.get_x() + p.get_width() / 2., p.get_height()), ha='center', va='center', fontsize=11, color='black', xytext=(0, 5), textcoords='offset points')

plt.show()

# Weather
## This bar plot displays the distribution of clothing items based on their suitability for different weather conditions.

plt.figure(figsize=(10, 6))
sns.countplot(data=inventory_df, x='weather', order=inventory_df['weather'].value_counts().index)
plt.title('Distribution of Clothing Weather Suitability')
plt.xlabel('Weather')
plt.ylabel('Count')
plt.xticks(rotation=30)

ax = plt.gca()
for p in ax.patches:
    ax.annotate(f'{int(p.get_height())}', (p.get_x() + p.get_width() / 2., p.get_height()), ha='center', va='center', fontsize=11, color='black', xytext=(0, 5), textcoords='offset points')

plt.show()

# Colors
## This bar plot presents the distribution of clothing items according to their colors.

sns.countplot(data=inventory_df, x='color', order=inventory_df['color'].value_counts().index)
plt.title('Distribution of Clothing Colors')
plt.xlabel('Color')
plt.ylabel('Count')
plt.xticks(rotation=30)

ax = plt.gca()
for p in ax.patches:
    ax.annotate(f'{int(p.get_height())}', (p.get_x() + p.get_width() / 2., p.get_height()), ha='center', va='center', fontsize=11, color='black', xytext=(0, 5), textcoords='offset points')

plt.show()

# Style Distribution for Each Category
## These bar plots depict the distribution of clothing styles within each category (e.g., dresses, tops, bottoms).

category_names = {
    'dresses': 'Dress',
    'top': 'Top',
    'bottom': 'Bottom',
    'knit': 'Knit',
    'jacket_coat': 'Jacket / Coat',
    'jumpsuit_romper': 'Jumpsuit / Romper'
}

unique_categories = inventory_df['category'].nunique()
grid_size = math.ceil(math.sqrt(unique_categories))

# Create a grid of subplots
fig, axes = plt.subplots(grid_size, grid_size, figsize=(15, 15))
axes = axes.flatten()

for i, category in enumerate(inventory_df['category'].unique()):
    sns.countplot(data=inventory_df[inventory_df['category'] == category], x='style', ax=axes[i])
    axes[i].set_title(f'Style Distribution for {category_names[category]}', fontsize=12)
    axes[i].set_xlabel('Style', fontsize=10)
    axes[i].set_ylabel('Count', fontsize=10)
    axes[i].tick_params(axis='x', rotation=45, labelsize=8)
    axes[i].tick_params(axis='y', labelsize=8)

    for patch in axes[i].patches:
        axes[i].annotate(str(int(patch.get_height())), (patch.get_x() + patch.get_width() / 2., patch.get_height()),
                    ha='center', va='center', fontsize=8, color='black', xytext=(0, 5),
                    textcoords='offset points')

for j in range(unique_categories, grid_size*grid_size):
    fig.delaxes(axes[j])

plt.tight_layout()
plt.show()

# Style Distribution for Each Category
## These bar plots demonstrate the distribution of clothing items based on their suitability for different weather conditions within each category.

import math
import matplotlib.pyplot as plt
import seaborn as sns

category_names = {
    'dresses': 'Dress',
    'top': 'Top',
    'bottom': 'Bottom',
    'knit': 'Knit',
    'jacket_coat': 'Jacket / Coat',
    'jumpsuit_romper': 'Jumpsuit / Romper'
}

unique_categories = inventory_df['category'].nunique()
grid_size = math.ceil(math.sqrt(unique_categories))

fig, axes = plt.subplots(grid_size, grid_size, figsize=(15, 15))
axes = axes.flatten()

for i, category in enumerate(inventory_df['category'].unique()):
    sns.countplot(data=inventory_df[inventory_df['category'] == category], x='weather', ax=axes[i])
    axes[i].set_title(f'Weather Suitability Distribution for {category_names[category]}', fontsize=12)
    axes[i].set_xlabel('Weather', fontsize=10)
    axes[i].set_ylabel('Count', fontsize=10)
    axes[i].tick_params(axis='x', labelsize=8)
    axes[i].tick_params(axis='y', labelsize=8)

    for patch in axes[i].patches:
        axes[i].annotate(str(int(patch.get_height())), (patch.get_x() + patch.get_width() / 2., patch.get_height()),
                    ha='center', va='center', fontsize=8, color='black', xytext=(0, 5),
                    textcoords='offset points')

for j in range(unique_categories, grid_size*grid_size):
    fig.delaxes(axes[j])

plt.tight_layout()
plt.show()

## This heatmap visualizes the count of clothing items for each combination of style and weather condition.
## It helps identify correlations between fashion styles and weather suitability.

heatmap_data = inventory_df.groupby(['style', 'weather']).size().unstack(fill_value=0)
plt.figure(figsize=(12, 8))
sns.heatmap(heatmap_data, cmap='coolwarm', annot=True, fmt='d')
plt.title('Style vs Weather Suitability Heatmap')
plt.xlabel('Weather Suitability')
plt.ylabel('Style')
plt.show()

## This heatmap displays the count of clothing items for each combination of weather condition and category.

category_labels_mapping = {
    'dresses': 'dress',
    'top': 'top',
    'bottom': 'bottom',
    'knit': 'knit',
    'jacket_coat': 'jacket / coat',
    'jumpsuit_romper': 'jumpsuit / romper'
}

# Apply the relabeling to the category column
inventory_df['category_relabel'] = inventory_df['category'].map(category_labels_mapping)

# Create the heatmap
heatmap_data = inventory_df.groupby(['weather', 'category_relabel']).size().unstack(fill_value=0)
plt.figure(figsize=(12, 8))
sns.heatmap(heatmap_data, cmap='coolwarm', annot=True, fmt='d')
plt.title('Weather vs Category Heatmap')
plt.xlabel('Category')
plt.ylabel('Weather')
plt.show()

"""NGROK = Tunnel to the Internet.

Using Flash
"""

